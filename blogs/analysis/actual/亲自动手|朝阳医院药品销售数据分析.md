---
title: "朝阳医院药品销售数据分析"
date: 2020-08-26
draft: false
tags: ["pandas","numpy"]
categories: ["数据分析实战"]
---

## 前言

先来囊括一下数据分析的流程，大致分为以下几个部分：

1. 提出问题

2. 理解数据

3. 数据清洗

4. 构建模型

5. 数据可视化

## 提出问题

在进行数据分析之前，先要明确分析的目标是什么，只有这样才能更为高效的选取数据，进行分析研究，最终产生价值。

本次目标是从销售数据中分析书以下业务指标：

- 月均消费次数

- 月均消费金额

- 客单价

- 消费趋势

有了目标，接下来关注下数据的情况

## 理解数据

1.导入数据包，提取数据文件

在提取数据中，为了保证数据文件中的数据读取正常，通常会将函数中dtype参数设置为`object`
意思是统一按照字符串格式读取数据


```python
import numpy as np
import pandas as pd
#导入数据
salesDf=pd.read_excel(r"朝阳医院2018年销售数据.xlsx",dtype='object')
# salesDf=xls.parse("数据1")
```

2.查看导入数据的基本状况


```python
#查看数据类型
type(salesDf)
```
pandas.core.frame.DataFrame


```python
#查看每个项目的类型
salesDf.dtypes
```
    购药时间    object
    社保卡号    object
    商品编码    object
    商品名称    object
    销售数量    object
    应收金额    object
    实收金额    object
    dtype: object

```python
#查看数据的基本大小
salesDf.shape
```
(6578, 7)

```python
#查看开头几行数据，看看数据是否读取正确
salesDf.head()
```

```python
#用描述函数describ查看整个数据的基本状况
salesDf.describe()
```

## 数据清洗

取得数据并不能直接进行分析，通常并不完全符合分析条件，可能存在缺失值、异常值，这些数据会使分析结果产生偏差，所以分析前需进行**子集选择**、**缺失数据补充**、**异常值处理**、**数据类型转换**等多个步骤，这些都属于数据清洗范畴。

在数据分析中，通常会超过60%的时间花在清洗中。

清洗步骤有如下几步：

- 选择子集

- 列名重命名

- 缺失数据处理

- 数据类型转换

- 数据排序

- 异常值处理

这些步骤可能还需重复操作

### 1.选择子集

此项目数据忽略选择子集

### 2.列名重命名

销售数据，购药时间显示为销售时间更为合理


```python
#购药时间-销售时间
nameChangeDict={"购药时间":"销售时间"}
#inplace=True表示覆盖元数据集
salesDf.rename(columns=nameChangeDict,inplace=True)
```

现在再来显示下数据，可以发现已经更新为了销售时间


```python
salesDf.head()
```


### 3.缺失数据处理

对于缺失数据，可以有以下几种处理方法：

- 删除

- 合理值填充


```python
#查看下哪些项目存在缺失值
salesDf.isnull().any()
```




    销售时间    True
    社保卡号    True
    商品编码    True
    商品名称    True
    销售数量    True
    应收金额    True
    实收金额    True
    dtype: bool



每个项目都存在缺失值


```python
#通常用isnull函数来查找缺失值
salesDf[salesDf[['销售时间','社保卡号']].isnull().values==True]
```


```python
#序号6574重复
naDf = salesDf[salesDf[['销售时间','社保卡号']].isnull().values == True].drop_duplicates()
naDf
```


```python
#缺失数据行数
naDf.shape[0]
```

3


删除缺失数据 


```python
#删除前显示数据集规模
salesDf.shape
```
(6578, 7)


```python
#删除销售时间和社保卡号的缺失数据
salesDf=salesDf.dropna(subset=['销售时间','社保卡号'],how='any')
```


```python
#删除后显示数据集规模
salesDf.shape
```
(6575, 7)


在数据删除后要及时更新一下最新的序号，不然可能会产生问题。我开始做的时候，在这里没有更新数据序号，导致后续销售时间数据类型用函数转换后与元数据合并时发生了错位，数据发生了新的缺失，后来发现导致问题产生的原因在这里。


```python
#重命名行号（index）:排序后的列索引值是之前的行号，需修改成从0到N按顺序的索引值
salesDf=salesDf.reset_index(drop=True)
```

### 4.数据类型转换


数量、金额项目：从字符串类型转换为数值类型


```python
salesDf.head()
```

```python
salesDf['销售数量']=salesDf['销售数量'].astype("float")
salesDf['应收金额']=salesDf['应收金额'].astype("float")
salesDf['实收金额']=salesDf['实收金额'].astype("float")
```


```python
salesDf.dtypes
```

    销售时间     object
    社保卡号     object
    商品编码     object
    商品名称     object
    销售数量    float64
    应收金额    float64
    实收金额    float64
    dtype: object



日期项目：从字符串类型转换为日期类型


```python
#日期转换
def dateChange(dateSer):
    dateList=[]
    for i in dateSer:
        str=i.split(' ')[0]
        dateList.append(str)
    dateChangeSer=pd.Series(dateList)
    return dateChangeSer
```


```python
dateChangeSer=dateChange(salesDf['销售时间'])
salesDf['销售时间']=dateChangeSer
salesDf.head()
```


做完转化后再观察有无新的缺失值


```python
salesDf['销售时间'].isnull().any()
```

False




```python
salesDf.dtypes
```




    销售时间     object
    社保卡号     object
    商品编码     object
    商品名称     object
    销售数量    float64
    应收金额    float64
    实收金额    float64
    dtype: object



没有新的缺失情况下，把销售时间的数据类型转为日期型


```python
dateSer=pd.to_datetime(salesDf['销售时间'],format='%Y-%m-%d',errors='coerce')
dateSer
```




    0      2018-01-01
    1      2018-01-02
    2      2018-01-06
    3      2018-01-11
    4      2018-01-15
              ...    
    6570   2018-04-27
    6571   2018-04-27
    6572   2018-04-27
    6573   2018-04-27
    6574   2018-04-28
    Name: 销售时间, Length: 6575, dtype: datetime64[ns]




```python
dateSer.isnull().any()
```
True




```python
compareDf = pd.DataFrame(dateSer[dateSer.isnull()],salesDf[dateSer.isnull()]['销售时间'])
compareDf
```


```python
salesDf['销售时间']=dateSer
salesDf.dtypes
```




    销售时间    datetime64[ns]
    社保卡号            object
    商品编码            object
    商品名称            object
    销售数量           float64
    应收金额           float64
    实收金额           float64
    dtype: object




```python
salesDf.shape
```
(6575, 7)



对缺失值进行简单删除处理


```python
salesDf=salesDf.dropna(subset=['销售时间','社保卡号'],how='any')
salesDf.shape
```
(6552, 7)




```python
#每次删除数据后都要重命名行号
salesDf=salesDf.reset_index(drop=True)
```

### 5.数据排序

销售记录一般是以销售时间为顺序排序


```python
#按销售时间排序
salesDf=salesDf.sort_values(by='销售时间')
```


```python
salesDf.head()
```


```python
#再次更新序号
salesDf=salesDf.reset_index(drop=True)
```


```python
salesDf.head()
```



### 6.异常值处理


```python
salesDf.describe()
```


从上面指标可以看出，存在销售数量为负的数据，显然不合理，需要将这部分数据删除


```python
#删除异常值：通过条件判断筛选处数据
#查询条件
querySer=salesDf.loc[:,"销售数量"]>0
```


```python
#删除异常值前
salesDf.shape
```




    (6552, 7)




```python
#应用查询条件
salesDf=salesDf.loc[querySer,:]
```


```python
#删除异常值后
salesDf.shape
```

(6509, 7)



数据清洗完了之后，终于可以搭建模型了

## 4.构建模型

### 1.业务指标

月均消费次数=总消费次数/月份数

总消费次数：同一天内，同一个人发生的所有消费算作一次消费。这里根据列名(销售时间社区卡号)结合，如果这两列值同时相同，只保留1条，将重复的数据删除

月份数：数据已经按照销售时间进行排序，只需将最后的数据与第一条数据相减就换算处月份数


```python
#总消费次数计算
kpDf=salesDf.drop_duplicates(subset=['销售时间','社保卡号'])
total=kpDf.shape[0]
total
```
5345




```python
#月份数计算
startDay=salesDf.loc[0,'销售时间']
print("开始日期：",startDay)
endDay=salesDf.loc[salesDf.shape[0]-1,'销售时间']
print("结束日期：",endDay)
monthCount=(endDay-startDay).days//30
print("月份数：",monthCount)
```

    开始日期： 2018-01-01 00:00:00
    结束日期： 2018-07-18 00:00:00
    月份数： 6



```python
salesDf.loc[0,'销售时间']
```




    Timestamp('2018-01-01 00:00:00')




```python
#业务指标1:月均消费次数=总消费次数/月份数
kpi1=total/monthCount
print("业务指标1:月均消费次数=",kpi1)
```

    业务指标1:月均消费次数= 890.8333333333334


### 指标2:

月均消费金额=总消费金额/月份数


```python
totalMoney=salesDf['实收金额'].sum()
kpi2=totalMoney/monthCount
print("业务指标2:月均消费金额=",kpi2)
```

    业务指标2:月均消费金额= 50672.494999999995


### 指标3

客单价=总消费金额/总消费次数


```python
kpi3=kpi2/kpi1
print("业务指标3:客单价=",kpi3)
```

    业务指标3:客单价= 56.88212722170252


### 指标4

消费趋势，画图：折线图


```python
#在进行操作之前，先把数据复制到另一个数据框中，防止对之前清洗后的数据框造成影响
groupDf=salesDf
#第1步：再次重命名行（index）为销售时间所在列的值
groupDf.index=groupDf['销售时间']
groupDf.head()
```


```python
#第2步：分组
gb=groupDf.groupby(groupDf.index.month)
```


```python
#第3步：应用函数，计算每个月的消费总额
monthDf=gb.sum()
monthDf
```


```python
#解决图表中中文表示不正的问题
import matplotlib as mpl
mpl.rcParams['font.sans-serif'] = ['SimHei']
mpl.rcParams['font.serif'] = ['SimHei']
import seaborn as sns
sns.set_style("darkgrid",{"font.sans-serif":['simhei', 'Arial']})
import matplotlib.pyplot as plt
%matplotlib inline
# from matplotlib.font_manager import _rebuild
# _rebuild() #reload一下
#绘制销售数量图
plt.plot(monthDf['销售数量'],color = 'b')
plt.title('销售趋势')
plt.xlabel('2018年月份')
plt.ylabel('销售数量')
```
Text(0, 0.5, '销售数量')

![消费趋势](images/202008/消费趋势.png)

```python
#设置图片大小
fig = plt.figure(figsize=(10,6))
#应收金额图
plt.plot(monthDf['应收金额'],color = 'r',label = '应收金额')
#实收金额图
plt.plot(monthDf['实收金额'],color = 'b',label = '实收金额')
#图标位置
plt.legend(loc='lower left')
#大标题
plt.title('应收金额与实收金额')
#X坐标标签
plt.xlabel('2018年月份')
#Y坐标标签
plt.ylabel('金额')
```
Text(0, 0.5, '金额')

![应收金额与实收金额](images/202008/应收金额与实收金额.png)


从途中可以看出销售数量和销售金额的整个趋势是基本一致的

四月份为最高点，二月份为前期一个最低点，而且四月份以后销售一直处于向下的趋势

在记录的日期中，七月份达到了历史最低水平

### 总结

1.如果是默认索引的话，在数据清洗中发生数据行数的变化时，应该要用`reset_index`函数及时把索引最新化，这样可以避免很多意料之外的错误。

2.数据量不是很大的情况下，对于缺失值，应该多观察，看能不能进行转换成合理的值，
比如这个数据集中【2018-02-29】这样的数据很可能是业务员录入失误导致，
可以通过了解实际情况后修改数据。

3.画图时发现中文标题，xy坐标标识无法正常显示，通过加了关于字体的设置后解决了问题


